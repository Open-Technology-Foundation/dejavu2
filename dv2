#!/bin/bash
#shellcheck disable=SC2155,SC2034,SC2174,SC1090,SC1091
set -e
shopt -s extglob globstar checkwinsize

declare -ar PRGNAME=( DéjàVu-DéjàVu DéjàVu2 DV2 dv2 )

declare -- AUTHOR='Gary Dean, garydean@okusi.id'
declare -- URL='https://github.com/Open-Technology-Foundation/dejavu2'

declare -- PRG0;    PRG0=$(readlink -en -- "$0")
declare -- PRGDIR;  PRGDIR=$(dirname "$PRG0")
declare -- PRG;     PRG=$(basename "$PRG0")

declare -- openai=$(command -v openai)
declare -- man=$(command -v man)
declare -- mdless=$(command -v mdless || true)
declare -- version="$(head -qzn1 "$PRGDIR"/.version)"

# basic application functions --------------------------------------------------
# semantic helper functions
msg()      { (($#)) || return 0; echo -n "$PRG: "; echo "$@"; }
msg.info() { >&2 msg "$@"; }
msg.err()  { >&2 msg "$@"; }
msg.die()  { >&2 msg "$@"; exit 1; }

# _declarep() returns entire declare strings, + errors;
_declarep()  { (($#)) || return 1; 2>/dev/null declare -p "$@"; }
# declarep() returns parts of declare strings (0-3), does not return error.
declarep() {
  (($#)) || return 0;
  local -i _fieldstart="$1"
  shift
  (($#)) || return 0;
  local -a _vars=()
  while(($#)); do
    _vars+=( "$(declare -p "$1" 2>/dev/null || echo '')" )
    shift
  done
  local -- _line
  for _line in "${_vars[@]}"; do
    [[ -z "$_line" ]] && continue
    ((_fieldstart>=1)) && _line="${_line/declare /}"
    ((_fieldstart>=2)) && _line="${_line#* }"
    echo "$_line"
  done
  unset _fieldstart _line _vars
}

# readline history -------------------------------------------------------------
#shellcheck disable=SC2120,SC2015
set_readline_history_file() {
  [[ -f "${HISTFILE:-}" ]] && history -a "$HISTFILE" || true
  local -- histfile=${1:-}
  [[ -z "$histfile" ]] && histfile="${HOME}/.${PRG}_history"
  declare -xg HISTFILE="$histfile"
  [[ -f "${HISTFILE:-}" ]] || touch "$HISTFILE"
  declare -xg HISTCONTROL=ignoredups:ignorespace
  declare -xg HISTFILESIZE=2000
  declare -xg HISTSIZE=1000
  declare -xg HISTTIMEFORMAT='%m-%d_%T '
  history -r "$HISTFILE"
}

# interactive settings ---------------------------------------------------------
declare -i markdown=0
declare -i verbose=1
declare -i wordwrap=1
declare -- less=cat
declare -i interactive
interactive=$(  [ -t 0 ] && echo 1 || echo 0 )
#shellcheck disable=SC2209
set_interactive() {
  [[ -z "${1:-}" ]] && { _declarep interactive wordwrap less; return 0; }
  if [[ $1 == 'on' ]] || (($1 > 0)); then
    interactive=1
    wordwrap=1
    less=$(command -v less)
  elif [[ $1 == 'off' ]] || (($1 == 0)); then
    interactive=0
    wordwrap=0
    less=cat
  fi
}
declare -fx 'set_interactive'
set_interactive "$interactive"

declare -i exit_on_completion=0

declare -i auto_max_tokens=1

# Note: After command line processing, languages becomes languages[].
declare -- languages=English
# Note: After command line processing, language becomes ->languages[0].
declare -- language=English

declare -- system='' user='' assistant=''

declare -- primary_directive='Your role is to assist the user in whatever manner.'
declare -n PD=primary_directive
declare -a messages=()
declare -- role='' content='' content1=''
declare -- model=gpt-4
declare -i token_limit=8000
declare -i max_tokens=4000
declare -- temperature=0.00729735256931
declare -i n=1
declare -- top_p=1
declare -- stop=''

declare -i used_tokens=0
declare -i statusline=1

declare -a Cmd_Cache=()

declare -a CONF_FILES=()
declare -- Conf_File=''
declare -n AGENT_FILES=CONF_FILES
declare -n Agent_File=Conf_File
# READ sys_lib ==========================================================
source "$PRGDIR"/.sys_lib
declare -n DV2_USER_HOME=APP_USER_HOME
declare -- DV2_AGENTS_HOME="$DV2_USER_HOME/agents"
declare -- DV2_SESSION_ID="$(date +%s).$RANDOM.420"
Cache_Dir="$Cache_Dir/$DV2_SESSION_ID"
declare -n DV2_CACHE_DIR=Cache_Dir
[[ -d "$DV2_CACHE_DIR" ]] || mkdir -m 0775 -p -- "$DV2_CACHE_DIR"

declare -a sys_vars=(
    CONF_FILES AGENT_FILES
    Conf_File Agent_File
    ''
    APP_USER_HOME DV2_USER_HOME
    ''
    DV2_AGENTS_HOME
    ''
    Cache_Dir DV2_CACHE_DIR
    ''
    system user assistant
    ''
    model
    token_limit max_tokens auto_max_tokens
    temperature top_p n stop
    ''
    verbose interactive wordwrap less exit_on_completion markdown mdless
    ''
    languages language
    ''
    HISTFILE
    ''
)

# g_messages[] -----------------------------------------------------------------------------
declare -a g_messages=()
declare -i g_messages_len=0
## LOAD AGENT FILE/s ==============================================================
process_g_messages() {
  # Transform messages[] -> g_messages[]
  # Re-declare g_messages[]
  unset g_messages g_messages_len
  declare -ag g_messages=()
  declare -ig g_messages_len=${#primary_directive}+10

  local _line _role _content
  for _line in "${messages[@]}"; do
    _role=${_line%%:*}; role=${role,,}
    if [[ -z "$_role" ]]; then
      ((verbose>1)) && msg.info "${FUNCNAME[0]}: warning: blank 'role' field. Ignoring. But you might want to look at it."
      continue
    fi
    if [[ ' system user assistant ' != *" $_role "* ]]; then
      ((verbose>1)) && _declarep _line messages
      msg.err "${FUNCNAME[0]}: Invalid role '$_role'"
      return 1
    fi
    _content="${_line#*:}"
    g_messages+=('-g' "$_role" "$(echo -ne "$_content")")
    g_messages_len+=${#_content}+10
  done
  unset _line _role _content
  return 0
}

load_agent_file() {
  local -a _agent=()
  while(($#)); do
    ((verbose>1)) && msg.info "${FUNCNAME[0]}: Processing Agent $1..."
    [[ -f "$1" ]] || {
      ((verbose>1)) && msg.info "${FUNCNAME[0]}: file '$1' not found."
      shift; continue
    }
    source "$1" || {
      ((verbose>1)) && msg.err "${FUNCNAME[0]}: source '$1' failed."
      shift; continue
    }
    process_g_messages || {
      shift; continue
    }
    _agent+=("$1")
    shift
  done
  AGENT_FILES=( "${_agent[@]}" )
  ((verbose>1)) && msg.info "Agents (${AGENT_FILES[*]}) Loaded."
  Agent_File=${AGENT_FILES[-1]}
  unset _agent
  return 0
}

# READ CONFIG/AGENT FILES =====================================================
declare -- _file
while(($#)) && [[ ${1:0:1} != '-' ]]; do
  _file=$(readlink -fn "$1")
  if [[ ! -f "$_file" ]]; then
    [[ "$_file" == *".agent.dv2" ]] && msg.die "File '$1' not found."
    _file=$(readlink -fn "${1}.agent.dv2")
    if [[ ! -f "${_file}.agent.dv2" ]]; then
      msg.die "File '$1' not found."
    fi
  fi
  AGENT_FILES+=( "$_file" )
  shift
done
unset _file
load_agent_file "${AGENT_FILES[@]}"

# ON ERROR --------------------------------------------------------------------
# on_error=continue|resume|ignore|stop|exit
# default is exit (~set -e)
declare -- on_error='exit'
# trap EXIT
trap_exit() {
  local -i _err=$?
  (($#)) && _err=$1
  exec 0</dev/tty
  [[ -d "${DV2_CACHE_DIR:-}" ]] && { rm -rf "$DV2_CACHE_DIR" || true; }
  ((verbose && _err && _err!=4)) && msg.err "error: $_err"
  exit "$_err"
}
trap 'trap_exit' EXIT
declare -r trap_EXIT="$(trap -p EXIT)"
# trap ERR
trap_error() {
  case "$on_error" in
    exit)
      ((verbose)) && msg.err 'aborting.'
      return 1
      ;;
    stop)
      ((verbose && ${#Cmd_Cache[@]})) \
        && msg.err 'script mode stopped.'
      Cmd_Cache=()
      return 0
      ;;
    continue|ignore|resume)
      ((verbose)) && msg.err "${on_error:0:-1}ing..."
      return 0
      ;;
  esac
  return 0
}
declare -i ret_value=0
trap 'trap_error; ret_value=$?; [ $ret_value -eq 1 ] && exit 1' ERR
declare -r trap_ERR="$(trap -p ERR)"
# trap int (ctrl-c)
trap_int() {
  ((verbose && interactive)) && echo >&2
  exit 4
}
trap 'trap_int' INT ABRT
declare -r trap_INT="$(trap -p INT)"

trap_push() {
  ((verbose>1)) && msg.info "$cmd: Pushing traps"
  local -- _cache_file="$DV2_CACHE_DIR/$(date -In |tr '+:T,' '_')-trap_push.bash"
  trap -p >"$_cache_file"
}
trap_pop() {
  ((verbose>1)) && msg.info "$cmd: Popping traps"
  local -- _cache_file
  _cache_file="$(find "$DV2_CACHE_DIR" -maxdepth 1 -name "*-trap_push.bash" -type f | sort | tail -n1)"
  if [[ -z "$_cache_file" ]]; then
    msg.err "$cmd: No trap files found to pop."
    return 0
  fi
  if [[ -f "$_cache_file" ]]; then
    source "$_cache_file" 2>/dev/null || true
    rm -f -- "$_cache_file"
    ((verbose>1)) && msg.info "$cmd: removed '$_cache_file'"
  else
    ((verbose>1)) && msg.err "$cmd: '$_cache_file' not found."
  fi
  return 0
}
trap_clear() {
  ((verbose>1)) && msg.info "$cmd: clearing trap push cache"
  find "$DV2_CACHE_DIR" -maxdepth 1 -name "*-trap_push.bash" -type f -delete
  ((verbose>1)) && msg.info "$cmd: traps cleared '$DV2_CACHE_DIR'"
}
traps() {
  local -a _arr=()
  local -i _n
  local -- _s _sn
  echo "# Current Traps:"
  trap -p |sed "s/^/    /"
  echo
  echo "# All Signals:"
  readarray -t -d$'\t' _arr < <(trap -l |tr $'\n' $'\t')
#  ((${#_arr[@]})) && _arr[-1]="${_arr[-1]%$'\n'}"
  for _s in "${_arr[@]}"; do
    [[ -z "$_s" ]] && continue
    _sn=${_s%)*}
    [[ -z "$_sn" ]] && continue
    _n=$(("$_sn")) 2>/dev/null || continue
    echo "${_s// SIG/ } $(trap -p "$_n")"
  done |sort -k2 |sed "s/^/    /g"
  unset _arr _n _s _sn
}

set +e
## NOTE: all untrapped errors from now on
##       are handled by trap_error().
# -- end on_error --------------------------------------------------

set_readline_history_file

#===================================================================
main() {
  local arg1=''
  # Process command line arguments and options
  while(($#)); do
    # var=value arguments
    if [[ "$1" =~ ^[a-zA-Z_][a-zA-Z0-9_]*= ]]; then
      arg1="${1%=*}"
      arg1=${arg1//-/_}
      [[ -z "$(_declarep "$arg1")" ]] \
          && { msg.err "Invalid variable declaration '$1'"; return 1; }
      eval "$1" || return 1
      shift
      continue
    fi
    #shellcheck disable=SC2206
    case "$1" in
      -m|--model)
                shift; model=${1:-$model}
                ;;
      -t|--temperature)
                shift; temperature=${1:-0.0072973525693}
                ;;
      -g|--message)
                shift; (($# < 2)) && { msg.err "Option -g|--message requires two arguments."; return 22; }
                role="${1,,}"
                [[ $role == 'system' || $role == 'user' || $role == 'assistant' ]] \
                    || { msg.err "Invalid option -g|--message '$role'. Role must be system, user, or assistant."; return 22; }
                shift; content="$1"
                [[ -n "$content" ]] \
                    && messages+=( "$role: $content" )
                ;;
      -k|--token-limit|--token_limit)
                shift; token_limit=${1:- $token_limit}
                ;;
      -M|--max-tokens|--max_tokens)
                shift; max_tokens=${1:- $token_limit}
                ;;
      -c|--command|--cmd)
                shift
                [[ -n "${1:-}" ]] && Cmd_Cache+=( "$1" )
                ;;
      -x|--exit_on_completion|--quit|--exit)
                exit_on_completion=1
                ;;
      -L|--languages)
                shift; languages=( ${1//,/ } )
                ;;
      -l|--language)
                shift; languages+=( ${1//,/ } )
                ;;
      -w|--wordwrap)
                shift; wordwrap=${1:-1}
                ;;
      -v|--verbose)
                ((verbose<=0)) && verbose=1 || verbose+=1
                ;;
      -q|--quiet)
                ((verbose>=1)) && verbose+=-1 || verbose=0
                ;;
      -i|--interactive)
                set_interactive 1
                ;;
      -y|--not-interactive)
                set_interactive 0
                ;;
      -a|--auto-max-tokens)
                auto_max_tokens=1
                ;;
      -A|--no-auto-max-tokens)
                auto_max_tokens=0
                ;;
      -N|--no-statusline)
                statusline=0
                ;;
      -V|--version)
                echo "$PRGVER"; return 0
                ;;
      -h|--help)
                usage; return 0
                ;;
      -[mtgkMcxLlwvqiyaANVh]*) #shellcheck disable=SC2046 # de-aggregate aggregated short options
                set -- '' $(printf -- "-%c " $(grep -o . <<<"${1:1}")) "${@:2}"
                ;;
      -?|--*)   msg.err "Invalid option '$1'"
                return 22 ;;
      *)        msg.err "Invalid argument '$1'"
                return 2 ;;
    esac
    shift
  done

  # suck any stdin into Cmd_Cache[] -----------------------------------------------
  if [[ ! -t 0 ]]; then
    # Save current stdin to a new file descriptor 3
    exec 3<&0
    # Read from the original stdin (now on fd 3)
    while read -u 3 -r _line; do
      { [[ -z "$_line" ]] || [[ "${_line:0:1}" == '#' ]]; } && continue
      Cmd_Cache+=( "$_line" )
    done
    # Restore stdin to terminal for further input
    exec 0</dev/tty
  fi
  ((exit_on_completion)) && Cmd_Cache+=( '/exit now' )

  # Grant default user names for terminal display.
  [[ -z "$system" ]]    && system="$PRG"
  [[ -z "$user" ]]      && user="$USER@$HOSTNAME"
  [[ -z "$assistant" ]] && assistant="$model"

  # main loop =========================================================
  # Get the start time in seconds and nanoseconds since the Unix epoch
  local -- start_time="$(date +%s%N)"
  local -- cmd_type='/'
  while((1)); do
    used_tokens=$((g_messages_len / 4))
    while((1)); do
      # -- line off--------------------------------------------
      if ((verbose && statusline)); then
        local -- _prompt="#!$system $USER@$HOSTNAME:" _elapsed_s
        (( ${#PWD} > 43 )) \
            && _prompt+="...${PWD: -40}" \
            || _prompt+="$PWD"
        ((UID)) && _prompt+='$' || _prompt+='#'
        _prompt+=" -- $used_tokens/$token_limit"
        (( (token_limit - max_tokens - used_tokens) < $((token_limit/10)))) \
            && _prompt+='!!'
        _elapsed_s="$(echo "scale=3; $(($(date +%s%N)-start_time)) / 1000000000" | bc)"
        _elapsed_s=${_elapsed_s:0:6}; [[ ${_elapsed_s: -1} == '.' ]] && _elapsed_s=${_elapsed_s:0:-1}
        _prompt+=" -- ${_elapsed_s}s"
        echo >&2 -e "\x1b[38;5;240m\r${_prompt} $(head -c "$((COLUMNS - ${#_prompt} - 1))" < /dev/zero | tr '\0' '-')\x1b[0m"
        unset _prompt _elapsed_s
      fi

      # Command Cache -----------------------------------------
      if((${#Cmd_Cache[@]})); then
        if [[ -n ${Cmd_Cache[0]} ]]; then
          content=${Cmd_Cache[0]}
          ((verbose)) && {
            echo
            echo "[$(((${#g_messages[@]}/3)-1))] $user: $content"
          }
        fi
        unset 'Cmd_Cache[0]'; Cmd_Cache=("${Cmd_Cache[@]:1}")
      else
        # Interactive ------------------------------------------
        echo
        while((1)); do
          read -er -i "$cmd_type" -p "[$((${#g_messages[@]}/3))] $user: " content
          # Ignore blank and #comment lines
          [[ -z "$content" || ${content:0:1} == '#' ]] && continue
          [[ $content == '/' ]] \
              && { print_script_command_help; cmd_type='/'; continue; }
          [[ $content == '//' ]] \
              && { $man "$PRG"; continue; }
          [[ $content =~ ^//[a-zA-Z].* ]] \
              && { content="${content:1}"; break; }
          [[ $content =~ ^/\![a-zA-Z].* ]] \
              && { content="${content:1}"; break; }
          break
        done
        start_time="$(date +%s%N)"
        # Is it a DV2 /command?
        if [[ ${content:0:1} == '/' ]]; then
          cmd_type='/'
        # Is it a shell !command?
        elif [[ ${content:0:1} == '!' ]]; then
          cmd_type='!'
          ((${#content})) || content="/$SHELL"
          content="/shell ${content:1}"
        # Otherwise, it's for GPT.
        else
          cmd_type=''
        fi
        history -s "$content"; history -a "$HISTFILE"
      fi

      ## /COMMANDS ----------------------------------------------------
      # / signifies a command follows.
      #shellcheck disable=SC2207
      if [[ ${content:0:1} == '/' ]]; then
        ((${#content} > 1)) || { $man "$PRG"; continue; }
        [[ "$content" == *" "* ]] || content="$content "
        cmd="${content:1}"
        cmd="${cmd%% *}"
        cmd_args="${content#* }"
        on_error='stop'
        case "$cmd" in
          quit|exit|q)
              if ((!exit_on_completion)) && ((change_flag && interactive)) && [[ ${cmd_args,,} != 'now' ]]; then
                msg.info "Session has not been saved."
                read -r -n 1 -i y -p "$PRG: Save session? y/n "
                echo
                [[ "$REPLY" == 'y' ]] || return 0
                Cmd_Cache+=( '/save' '/exit now' )
              else
                return 0
              fi
              ;;
          interactive)
              set_interactive "${cmd_args}"
              ;;
          edit)
              ((!interactive)) && continue
              local _file
              # /edit messageNo
              if [[ $cmd_args =~ ^[0-9]+$ ]]; then
                local -i _g_message_no=$((cmd_args * 3))
                _file=$(mktemp --suffix="-msg-$cmd_args-${g_messages[_g_message_no+1]}")
                echo "${g_messages[_g_message_no+2]}" > "$_file"
                dv_shell "$EDITOR ${_file}" resume stop
                if [[ -s "${_file}" ]]; then
                  read -r -n 1 -i y -p "$PRG: Replace message #$cmd_args with '$_file'? y/n "
                  if [[ "$REPLY" == 'y' ]]; then
                    g_messages[_g_message_no+2]=$(cat "$_file")
                    ((verbose)) && Cmd_Cache+=( "/list $cmd_args" )
                  fi
                fi
                rm -f "$_file"
                unset _file _g_message_no
                continue
              fi
              ###
              _file="$cmd_args"
              local -i _oneshot=0
              # /edit with empty _file == long command
              if [[ -z "$_file" ]]; then
                _file=$(mktemp)
                _oneshot=1
              fi
              dv_shell "$EDITOR ${_file}" resume stop
              if [[ -s "$_file" && -r "$_file" ]]; then
                #/edit (oneshot)
                if ((_oneshot)); then
                  local -- _oneshot_cmd
                  _oneshot_cmd="$(cat "$_file")"
                  rm -f "$_file"
                  ((${#_oneshot_cmd} < 2048)) && history -s "$_oneshot_cmd"
                  Cmd_Cache+=( "$_oneshot_cmd" )
                  unset _oneshot_cmd _file _oneshot
                  break
                fi
                unset _oneshot

                if ((interactive)); then
                  read -r -n 1 -i y -p "$PRG: Execute '$_file'? y/n "
                  [[ "$REPLY" == 'y' ]] || { unset _file; continue; }
                fi
                local -- _e
                local -a _ecmd=()
                mapfile -t _ecmd < "$_file"
                for _e in "${_ecmd[@]}"; do Cmd_Cache+=("$_e"); done
                unset _e _ecmd
              fi
              unset _file _oneshot
              ;;
          cd|chdir)
              if ((${#cmd_args})); then
                cd "$cmd_args" || { msg.err "Failed to cd into '$cmd_args'"; }
              else
                pwd
              fi
              ;;
          shell)
              dv_shell "$SHELL -c '$cmd_args'" resume stop
              ;;
          status_clear)
              ((verbose>1)) && msg.info "$cmd: clearing push/pop cache"
              find "$DV2_CACHE_DIR" -maxdepth 1 -name "*-push.bash" -type f -delete
              ((verbose>1)) && msg.info "$cmd: cleared '$DV2_CACHE_DIR'"
              ;;
          status_pop)
              ((verbose>1)) && msg.info "$cmd: Popping status"
              local -- _cache_file
              _cache_file="$(find "$DV2_CACHE_DIR" -maxdepth 1 -name "*-push.bash" -type f | sort | tail -n1)"
              if [[ -z "$_cache_file" ]]; then
                msg.err "$cmd: No status push files found"
                continue
              fi
              if [[ -f "$_cache_file" ]]; then
                source "$_cache_file" 2>/dev/null || true
                rm -f -- "$_cache_file"
                ((verbose>1)) && msg.info "$cmd: removed '$_cache_file'"
              else
                ((verbose>1)) && msg.err "$cmd: '$_cache_file' not found."
              fi
              unset _cache_file
              ;;
          status_push)
              ((verbose>1)) && msg.info "$cmd: Pushing status"
              if [[ -n "$cmd_args" ]]; then
                cmd_args="${cmd_args,,}"
                [[ "$cmd_args" == 'all' ]] || {
                  msg.err "$cmd: invalid argument '$cmd_args"
                  continue
                }
              fi
              local -- _cache_file="$DV2_CACHE_DIR/$(date -In |tr '+:T,' '_')-push.bash"
              local _var _str=''
              ( echo '#!/bin/bash'
                echo
                echo "# GLOBAL_VARS[@]"
                if [[ $cmd_args == 'all' ]]; then
                  for _var in "${GLOBAL_VARS[@]}"; do
                    [[ -z "$_var" || ${_var:0:1} == '#' ]] && { echo "$_var"; continue; }
                    _declarep "$_var" \
                        || { _str="$cmd: Variable '$_var' not found.";
                             msg.err "$_str"; echo "# $_str"; }
                  done
                fi
                echo
                echo "# sys_vars[@]"
                for _var in "${sys_vars[@]}"; do
                  [[ -z "$_var" || ${_var:0:1} == '#' ]] && { echo "$_var"; continue; }
                  _declarep "$_var" \
                      || { _str="$cmd: Variable '$_var' not found.";
                           msg.err "$_str"; echo "# $_str"; }
                done
                echo
                _declarep system user assistant
                echo
                _declarep primary_directive
                echo
                [[ $cmd_args == 'all' ]] && { _declarep messages; echo; }
              ) > "$_cache_file"
              ((verbose>1)) && msg.info "$cmd$([[ -n "$cmd_args" ]] && echo ' all'): added '$_cache_file'"
              unset _cache_file _var _str
              ;;
          status) (
              echo "# $PRGVER -- $(date +'%F %T %z') --"
              local _var _str=''
              for _var in "${sys_vars[@]}"; do
                [[ -z "$_var" || "${_var:0:1}" == '#' ]] && { echo "$_var"; continue; }
                _str=$(_declarep "$_var" \
                  || { msg.err "$cmd: Variable '$_var' not found."; echo ''; } )
                [[ -z "$_str" ]] && continue
                echo -n '    '
                echo "$_str" | cut -d' ' -f2-
              done
              if [[ $cmd_args == 'all' ]]; then
                echo
                echo '# GLOBAL_VARS[@]'
                for _var in "${GLOBAL_VARS[@]}"; do
                  [[ -z "$_var"  || "${_var:0:1}" == '#' ]] && { echo "$_var"; continue; }
                  _str=$(_declarep "$_var" || { msg.err "$cmd: Variable '$_var' not found."; echo ''; } )
                  [[  -z "$_str" || "$_str" == *"$LF"* \
                      || "$_str" == *'GLOBAL_VARS'* ]] \
                    && continue
                 echo -n '    '
                 echo "$_str" | cut -d' ' -f2-
                done
                unset _var _str
              fi ) | $less
              ;;
          models|engines)
              [[ ${cmd_args,,} == 'update' ]] && get_openai_models 1
              ((interactive)) || { printf '%s\n' "${Models[@]}"; continue; }
              local -i _i _j _sel
              for((_i=0; _i<${#Models[@]}; _i++)); do
                _j=$((_i+1))
                printf '%s) %s\n' "$_j" "${Models[$_i]}$([[ $model == "${Models[$_i]}" ]] && echo '*')"
              done
              read -rp "$PRG: Select Model 0|1-${#Models[@]} " _sel
              ( [[ -z "$_sel" || $_sel == 'q' ]] \
                  || (( _sel == 0 || _sel > ${#Models[@]} ))
              ) && continue
              model="${Models[_sel-1]}"
              token_limit=$(context_window "$model")
              ((verbose)) && declarep 3 model token_limit
              continue
              ;;
          list)
              [[ -z "$cmd_args" ]] && cmd_args='all'
              local -a _nums
              _nums=( $(int_list "$cmd_args" 0 "$(( (${#g_messages[@]}/3)-1 ))" 0) ) \
                  || { unset _nums; continue; }
              ((${#_nums[@]} < 3)) && { unset _nums; continue; }
              local -i _i _ii
              (for _i in "${_nums[@]}"; do
                _ii=(_i*3)
                if ((interactive && wordwrap)); then
                  printf '%d) %s: %s\n' "$_i" "${g_messages[$((_ii+1))]}" "${g_messages[$((_ii+2))]}" | fmt -w ${COLUMNS:-80}
                else
                  printf '%d) %s: %s\n' "$_i" "${g_messages[$((_ii+1))]}" "${g_messages[$((_ii+2))]}"
                fi
                ((verbose)) && echo
              done) | $less
              unset _i _ii _nums
              ;;
          clear)
              messages=()
              process_g_messages
              AGENT_FILES=( "$Agent_File" )
              ;;
          delete)
              [[ -z "$cmd_args" ]] \
                  && { msg.err "delete: No message number/s specified."; continue; }
              local -a _nums
              _nums=( $(int_list "$cmd_args" 1   "$(( (${#g_messages[@]}/3)-1 ))" 0) ) \
                || continue
              ((interactive)) && {
                read -r -i n -n 1 -p "$PRG: Delete messages (${_nums[*]})? y/n "
                [[ "$REPLY" != 'y' ]] && continue
              }
              local -- _msg
              local -i _i _ii
              for _i in "${_nums[@]}"; do
                _ii=$((_i * 3))
                unset "g_messages[$_ii]" "g_messages[$((_ii+1))]" "g_messages[$((_ii+2))]"
                ((verbose && interactive)) && msg.err "Message #${_i} (->g_${_ii}) deleted"
              done
              # Remove unset elements from the array
              g_messages=( "${g_messages[@]:+${g_messages[@]}}" )
              _msg="${g_messages[*]}" # Concatenate all the strings in g_messages
              # Calculate the total length for token calcs
              g_messages_len=${#primary_directive}+${#_msg}+10
              unset _i _ii _nums _msg
              change_flag=1
              ;;
          agents)
              [[ -z "$cmd_args" ]] && cmd_args=$PWD
              local -a dvpaths=( "$cmd_args" )
              [[ $cmd_args == 'all' ]] && dvpaths+=( "$PRGDIR" /etc/default )
              dvpaths+=( "$PWD" "$PWD/.$PRG" "$DV2_USER_HOME/agents" "$HOME/.$PRG" )
              local _dir
              local -a _files
              _files=( $( \
                ( for _dir in "${dvpaths[@]}"; do
                    find "$_dir" \
                      -maxdepth 2 \
                      \( -name "*dv2.conf" -o -name "*.agent.dv2" \) \
                      -type f 2>/dev/null
                  done
                ) | sort -u)
              )
              local _ccc=0 _sel=0
              if (( ! (interactive && wordwrap) )); then
                printf '%s\n' "${_files[@]}"
                continue
              fi
              local -- _olddir='.' _newdir=''
              local -a _newfiles=( ".." )
              for _dir in "${_files[@]}"; do
                if [[ -f "$_dir" ]]; then
                  _newdir="$(dirname -- "$_dir")"
                  [[ _olddir != "$_newdir" ]] \
                    && {
                      _olddir=$_newdir
                      _newfiles+=( "$_newdir" )
                    }
                fi
                _newfiles+=( "$_dir" )
              done
              _files=( "${_newfiles[@]}" )
              unset _newfiles _olddir

              while((1)); do
                _ccc=0
                _newdir=''
                declarep 3 PWD
                for _dir in "${_files[@]}"; do
                  if [[ -d "$_dir" ]]; then
                    _newdir=$_dir
                    echo "$((++_ccc)) . ${_dir/"$PWD/"/}"
                  else
                    echo "$((++_ccc))     ${_dir/"$_newdir/"/}"
                  fi
                done
                local -- reply _elprompt
                while((1)); do
                  echo -ne "\033[2K\r"
                  read -rs -n 1 -i n -p "$PRG: edit, load, cd, quit: e|l|c|q " reply
                  [[ "${reply,,}" == 'q' || "${reply}" == '0' ]] && break 2
                  [[ "${reply,,}" == 'e' ]] && { _elprompt='edit'; break; }
                  [[ "${reply,,}" == 'l' ]] && { _elprompt='load'; break; }
                  [[ "${reply,,}" == 'c' ]] && { _elprompt='cd'; break; }
                done
                echo -ne "\033[2K\r"
                read -rp "$PRG: $_elprompt: 0|1-${#_files[@]} " _sel
                [[ $_sel == 'q' ]] && break
                [[ -z "$_sel" ]] || (( _sel == 0 || _sel > ${#_files[@]} )) \
                  && continue
                _selected="${_files[$((_sel-1))]}"
                #shellcheck disable=SC2015
                if [[ $reply == 'c' ]]; then
                  [[ ! -d "$_selected" ]] \
                    && _selected="$(dirname -- "$_selected")"
                  cd "$_selected" || true
                  continue
                elif [[ $reply == 'l' ]]; then
                  Cmd_Cache+=( "/load \"$_selected\"" )
                  break
                else
                  [[ -d "$_selected" ]] && continue
                  Cmd_Cache+=( "/edit \"$_selected\"" )
                  Cmd_Cache+=( "/$cmd $cmd_args" )
                  break
                fi
              done
              unset _dir _ccc _sel _files _selected reply
              ;;
          load)
              cmd_args=$(eval "echo -ne $cmd_args")
              [[ -f $cmd_args ]] || { msg.err "$cmd: Agent File '$cmd_args' not found."; continue; }
              load_agent_file "$cmd_args"
              change_flag=1
              ;;
          scripts)
              local -- _dir
              local -a _dirs=() _files=()
              local -i _ccc=0 _sel=0
              [[ -z "$cmd_args" ]] \
                  && _dirs=( "$PWD" "$PWD/.$PRG" "$DV2_USER_HOME" "$HOME/.$PRG" "$PRGDIR" ) \
                  || _dirs=( $(readlink -fn -- "$cmd_args") )
              _files=( $( \
                ( for _dir in "${_dirs[@]}"; do
                    [[ -d "$_dir" ]] || continue
                    ( find "$_dir" \
                      -maxdepth 1 \
                      -name "*.dv2" \
                      -type f 2>/dev/null \
                      | grep -v '.agent.dv2' ) \
                      || true
                  done
                ) | sort -u)
              )
              ((${#_files[@]})) || continue
              ((interactive)) || { printf '%s\n' "${_files[@]}"; continue; }
              while((1)); do
                _ccc=0
                for _dir in "${_files[@]}"; do
                  echo "$((++_ccc)) $_dir"
                done
                read -rp "$PRG: $(basename "$EDITOR") 0|1-${#_files[@]} " _sel
                ( [[ -z "$_sel" || $_sel == 'q' ]] \
                    || (( _sel == 0 || _sel > ${#_files[@]} ))
                ) && break
                dv_shell "$EDITOR ${_files[$((_sel-1))]}" resume
              done
              unset _dir _dirs _files _ccc _sel
              ;;
          save)
              local -- _filename
              ((interactive)) \
                && read -er -i "$cmd_args" -p "$PRG: Enter filename: " _filename
              [[ -z "$_filename" ]] && continue
              if [[ -f "$_filename" ]]; then
                ((interactive)) && {
                  read -r -n 1 -i n -p "$PRG: '$_filename' exists. Overwrite? y/n "
                  [[ "$REPLY" == 'y' ]] || continue
                }
              fi
              #shellcheck disable=SC2094
              unset messages
              declare -ag messages=()
              local -i _i
              for((_i=0; _i<${#g_messages[@]}; _i+=3)); do
                messages+=( "${g_messages[$((_i+1))]}:${g_messages[$((_i+2))]//$'\n'/\\n}" )
              done
              local -- _msg
              #shellcheck disable=SC2094
              ( echo '#!/bin/bash'
                echo
                echo "# Agent '$(basename "$_filename")'"
                echo "# Generated from $PRG session "
                echo "# with Agent '$(basename -- "$Agent_File")'"
                echo "# $(date +'%F %T %z')"
                echo
                declarep 2 system
                echo
                declarep 2 user assistant
                echo
                declarep 2 model token_limit max_tokens auto_max_tokens
                echo
                declarep 2 temperature n top_p stop
                echo
                declarep 2 verbose interactive exit_on_completion
                echo
                declarep 2 wordwrap markdown mdless less
                echo
                echo
                echo -n 'languages=( '
                for _msg in "${languages[@]}"; do
                  _msg="${_msg//\"/\\\"}"
                  [[ $_msg == *" "* ]] && echo -n "\"$_msg\" " || echo -n "$_msg "
                done
                echo ')'
                echo
                declarep 2 primary_directive
                echo
                if ((${#messages[@]})); then
                  echo 'messages=('
                  for _msg in "${messages[@]}"; do
                    _msg="${_msg//\"/\\\"}"
                    echo "\"$_msg\" "; echo
                  done
                  echo ')'
                fi
                echo
                echo '#fin'
              ) > "$_filename"
              unset _filename _i
              process_g_messages
              change_flag=0
              ;;
          *)  # Process variable-assignment arguments first
              local -- _arg1
              content1="${content:1}"
              content1="${content1%"${content1##*[^[:space:]]}"}"
              if [[ "$content1" =~ ^[a-zA-Z_][a-zA-Z0-9_]*= ]]; then
                _arg1="${content1%=*}"
                _arg1=${_arg1//-/_}
                if [[ -v "$_arg1" ]]; then
                  on_error='resume'
                  eval "$content1" || msg.err "eval fail for command '/$content1'"
                  on_error='stop'
                else
                  msg.err "Variable '$_arg1' is not present in $PRG"
                fi
              # If the cmd resembles a public system variable,
              # try to print it out.
              elif [[ "$content1" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
                _arg1=$( declarep 2 "$content1" || echo '')
                if [[ -z "$_arg1" ]]; then
                  _arg1=$( declare -Fp "$content1" 2>/dev/null || echo '')
                  if [[ -z "$_arg1" ]]; then
                    msg.err "Variable/Function '$content1' not found."
                  else
                    eval "$content1" || msg.err "eval fail for command '/$content1'"
                  fi
                else
                  echo "$_arg1"
                fi
              else
                msg.err "Invalid command '$cmd' |$content1|"
              fi
              on_error='stop'
              unset _arg1
              ;;
        esac
        continue
      fi
      ##
      break
    done
    on_error='exit'

    # INIT user content into conversation stream
    g_messages+=( '-g' user "$content" )
    g_messages_len+=${#content}+8

    # Organise Tokens
    token_limit=$(context_window "$model")
    used_tokens=$((g_messages_len / 4))
    ((max_tokens > token_limit)) && max_tokens=$token_limit
    if ((auto_max_tokens)); then
      if (( (max_tokens+used_tokens) > token_limit )); then
        max_tokens=$((token_limit - used_tokens - 200))
        if ((max_tokens < 200)); then
          ((verbose)) && msg.err "You have exceeded the token limit for this session."
          ((max_tokens < 200)) && max_tokens=200
        fi
        ((verbose)) && msg.info "max_tokens auto-adjusted to $max_tokens (used=${used_tokens} limit=${token_limit})"
      fi
    fi

    # Call openai
    local -- _PD_expanded
    eval "_PD_expanded=\"${primary_directive}\""
    # Print the expanded directive
    #echo "$directive_expanded"
    content=$($openai api chat_completions.create \
        --model        "$model" \
        --n            "$n" \
        --max-tokens   "$max_tokens" \
        --temperature  "$temperature" \
        --top_p        "$top_p" \
        --stop         "$stop" \
        -g system "$_PD_expanded" \
        "${g_messages[@]}"
    )
    unset _PD_expanded
    if [[ -n $content ]]; then
      change_flag=1
      g_messages+=( '-g' assistant "$content" )
      g_messages_len+=${#content}
      ((verbose)) && echo
      if ((interactive && wordwrap)); then
        if ((markdown)); then
          if [[ -n "$mdless" ]]; then
            echo "[$(((${#g_messages[@]}/3)-1))] $assistant: $content" | $mdless -cp
            echo -e "$RESET"
          else
            echo "[$(((${#g_messages[@]}/3)-1))] $assistant: $content" | md2ansi | $less
          fi
        else
          echo "[$(((${#g_messages[@]}/3)-1))] $assistant: $content" | fmt -w ${COLUMNS:-78} | $less
        fi
      else
        echo "[$(((${#g_messages[@]}/3)-1))] $assistant: $content"
      fi
    fi

    history -a "$HISTFILE"

    # If the command cache is empty and
    # we are in not interactive mode, then exit.
    if ((${#Cmd_Cache[@]} == 0)) && ((! interactive)); then
      break
    fi
  done
  history -a "$HISTFILE"
}

# Shell -------------------------------------------------------------------------------
##shellcheck disable=SC2064
dv_shell() {
  on_error="${2:-resume}"
  trap - INT ABRT ERR EXIT
  set +e ## NOTE
  eval "${1:-bash}"; true
  set +e ## NOTE
  trap "$trap_EXIT" EXIT
  trap "$trap_ERR"  ERR
  trap "$trap_INT"  INT
  on_error="${3:-stop}"
}


# Models ---------------------------------------------------------------------------
declare -a Models=()
get_openai_models() {
  local -i _force=${1:-0}
  local -- _engines_file="${DV2_USER_HOME:-"$PRGDIR"}"/openai.engines.list
  if [[ ! -f "$_engines_file" ]]; then
    _force=1
  else
    # Force update if more than 5 days old.
    (( ($(stat --printf='%Y' "$_engines_file") + 432000) < "$(date +%s)" )) && _force=1
  fi
  #shellcheck disable=SC2207
  if ((_force)); then
    ((verbose)) && msg.info "Updating openAI engines list"
    Models=( $($openai api engines.list \
              |grep '"id":' |sed 's/"id"://; s/",//' \
              |tr -d '" ' | grep ^gpt- |sort -u) ) \
      && printf '%s\n' "${Models[@]}" >"$_engines_file"
  else
    Models=( $(cat -s "$_engines_file") )
  fi
}
get_openai_models 0

# Context Window ("token_limit") ---------------------------------------------------
context_window() {
  local -i _k=2000
  (($#)) || { echo -n "$_k"; return 0; }
  [[ "$1" =~ ^gpt-.*-([0-9]+)k ]] \
    && { echo -n "${BASH_REMATCH[1]}000"; return 0; }
  local -a _arr=()
  readarray -t -d '-' _arr <<<"$1"
  ((${#_arr[@]})) && _arr[-1]="${_arr[-1]%$'\n'}"
  if    [[ ${_arr[1]} == '4' ]];   then _k=8000
  elif  [[ ${_arr[1]} == '3.5' ]]; then _k=4000
  fi
  echo -n "$_k"
}
token_limit=$(context_window "$model")

# Help ------------------------------------------------------------
usage() {
#shellcheck disable=SC2128
cat <<EOT
# ${PRGNAME} - AI Chatbot/Scriptbot for Bash terminal - ver $version

__"it's dejavu all over again."__

AI Agent creation and scripting for Bash terminal using openAI GPT models.

## Usage

  $PRG [agent] [-options] [<file]

  agent     Agent file (with '.agent.$PRG' filename extension).
            Optional, Positional; must be first argument,
            before any other options.

  file      .script.$PRG file, via stdin.

## Options

  -m|--model "model"
            openai [model=$model]

  -k|--token_limit N
            context window [token limit=$token_limit]
            Usually calculated automatically (see --auto-max-tokens).

  -M|--max_tokens N
            response tokens [max_tokens=$max_tokens]
            Usually calculated automatically (see --auto-max-tokens).

  -t|--temperature N.N
            [temperature=$temperature]

  -g|--message system|user|assistant "content..."
            eg, -g user "How did I get here?"

  -c|--command|--cmd "[/]cmd"
            Add ${PRGNAME[2]} /slash command _or_ gpt user prompt to command
            stack (Cmd_Cache[]).
            Can be used multiple times.

  -L|--languages "lang1,lang2,..."
            [languages='${languages[*]}']

  -x|--exit_on_completion|--exit
            Exit upon completion of commands/script.
            [exit_on_completion='$exit_on_completion']

  -v|--verbose
            verbose=1 [verbose=$verbose]
  -q|--quiet
            verbose=0

  -N|--statusline
            statusline=0 [statusline=$statusline]

  -i|--interactive
            interactive=1 [interactive=$interactive]
            yes-no prompts are enabled.

  -y|--not-interactive
            interactive=0
            yes-no prompts are disabled; default y.

  -a|--auto-max-tokens
            auto_max_tokens=1 [auto_max_tokens=$auto_max_tokens]
            Enable dynamic calculation of max_tokens to
            maximum available.

  -A|--no-auto-max-tokens
            auto_max_tokens=0
            Disable dynamic calculation of max_tokens.

  -a|--autosave on|off
            If on, upon exit, append current conversation to current
            ${PRGNAME[2]} script. Default is off.

  -u|--upgrade
             Upgrade ${PRGNAME[1]} from git repository.
             Git repository is set to:
                $URL

  -V|--version
            [version="$PRGVER"], exit

  -h|--help
            This help, exit
EOT
}

# -- Script Command Help Text ---------------------------------------------------
declare -- Script_Command_Help=''
get_script_command_help() {
  local -- _line
  local -a _man
  readarray -t _man < <($man dv2)
  local -i _i
  #shellcheck disable=SC2167,SC2165
  for((_i=0; _i<${#_man[@]}; _i++)); do
    _line=${_man[$_i]}
    if [[ "$_line" == 'DV2 Script Commands' ]]; then
      echo "$_line"
      for((_i=_i+1; _i<${#_man[@]}; _i++)); do
        _line=${_man[$_i]}
        # NOTE: Need to watch this for changes.
        [[ "$_line" == 'Prompt Engineering'  ]] && break 2
        [[ ${_line:0:8} == '        ' ]] \
          && echo "${_line:8}" \
          || echo "${_line}"
      done
      break
    fi
  done
  unset _man _i _line
}
print_script_command_help() {
  [[ -z "$Script_Command_Help" ]] \
    && Script_Command_Help=$(get_script_command_help)
  echo "$Script_Command_Help" | $less
}


main "$@"
#fin
